#!/usr/bin/env bash

##############
# Requirements
##############
# environnement variables
# - B3T_SSH_PORT: if need custom port for ssh-keyscan
# - NETBOX_API_TOKEN: in order to interract with Netbox
# - NETBOX_URL: netbox url target (exemple foo.bar). Note https is mandatory
# external tools
# - fzf
# - yq
# - curl
# - ssh
# - ssh-keyscan
# - git
# SSH command are based on elements retrieved with netbox export
# ensure you have b3t export templates
# instances:
# {%- for device in queryset %}
#   - name: "{{device.name}}"
#     status: "{{device.status}}"
# {%- endfor %}

b3t(){
    local BIN_NAME
    BIN_NAME="b3t"
    local B3T_CONFIG_DIR
    B3T_CONFIG_DIR="${HOME}/.config/b3t"
    local B3T_CACHE_DIR
    B3T_CACHE_DIR="${B3T_CONFIG_DIR}/cache"
    local B3T_CACHE_FILE_VM
    B3T_CACHE_FILE_VM="${B3T_CACHE_DIR}/vms.yaml"
    local B3T_CACHE_FILE_DEVICES
    B3T_CACHE_FILE_DEVICES="${B3T_CACHE_DIR}/devices.yaml"
    local B3T_KNOWN_HOSTS_FILE
    B3T_KNOWN_HOSTS_FILE="${B3T_CONFIG_DIR}/known_hosts"
    local B3T_SSH_PORT
    B3T_SSH_PORT="${B3T_SSH_PORT:-22}"

    local B3T_TALOS_DIR
    B3T_TALOS_DIR="${HOME}/.talos"

    local B3T_KUBE_CONFIG_DIR
    B3T_KUBE_CONFIG_DIR="${HOME}/.kube"

    if [ ! -d "$B3T_CONFIG_DIR" ]; then
        echo "First run create b3t config dir => ${B3T_CONFIG_DIR}"
        mkdir -p ${B3T_CONFIG_DIR}
    fi

    command_help(){
        echo "Usage: $BIN_NAME <subcommand>"
        echo "Subcommands:"
        echo "    ssh              Helpers to dialog with infrastructure"
        echo "    shortcut|sc      Helpers to dialog with shortcut"
        echo "    k8s|kubernetes   Helpers to dialog with k8s"
        echo "    talos            Helpers to dialog with talos"
    }

    command_ssh_scan(){
        echo "Running 'ssh/scan' command."

        _b3t_cache

        cat /dev/null > "${B3T_KNOWN_HOSTS_FILE}"

        for entry in $(yq .instances "${B3T_CACHE_FILE_DEVICES}" "${B3T_CACHE_FILE_VM}" | yq '.[] | select(.status == "active") | .name'); do
            echo "Processing device: ${entry}:${B3T_SSH_PORT}"
            ssh-keyscan -p "${B3T_SSH_PORT}" "${entry}" >> "${B3T_KNOWN_HOSTS_FILE}"
        done
    }

    command_ssh_connect(){
        echo "Running 'ssh/connect' command."

        SSH_TARGET=$(awk -F'[][]' '{ if (NF > 2) print $2 }' "${B3T_KNOWN_HOSTS_FILE}" | uniq | fzf --height=20 --ansi --reverse --select-1)
        if [ -z "${SSH_TARGET}" ]
        then
            echo "No host selected aborted"
            return
        fi

        history -s ssh ${SSH_TARGET}
        ssh ${SSH_TARGET}
    }

    _b3t_cache(){
        if [ ! -d "$B3T_CACHE_DIR" ]; then
            echo "First run create b3t cache => ${B3T_CACHE_DIR}"
            mkdir -p ${B3T_CACHE_DIR}
        fi

        if [ ! -f "${B3T_CACHE_FILE_VM}" ] || [ ! -f "${B3T_CACHE_FILE_DEVICES}" ]; then
            echo "Populate cache"

            mkdir -p ${B3T_CACHE_DIR}
            curl -o "${B3T_CACHE_DIR}/devices.yaml" --silent -H "Content-Type: application/json" -H "Authorization: Token $NETBOX_API_TOKEN" -L "https://${NETBOX_URL}/api/dcim/devices/?export=b3t"
            curl -o "${B3T_CACHE_DIR}/vms.yaml" --silent -H "Content-Type: application/json" -H "Authorization: Token $NETBOX_API_TOKEN" -L "https://${NETBOX_URL}/api/virtualization/virtual-machines/?export=b3t"
        fi
    }

    command_ssh_help(){
        echo "Usage: $BIN_NAME ssh <subcommand>\n"
        echo "Subcommands:"
        echo "    connect           make ssh connection to one instance"
        echo "    scan              (re)populate ssh_knows_hosts with fingerprint"
    }

    command_ssh(){
        subcommand=$1

        case "${subcommand}" in
        "connect")
            shift
            command_ssh_connect
            ;;
        "scan")
            shift
            command_ssh_scan
            ;;
        *)
            command_ssh_help
            ;;
        esac
    }

    command_shortcut_help(){
        echo "Usage: $BIN_NAME shortcut <subcommand>\n"
        echo "Subcommands:"
        echo "    branch   create branch base on ticket number"
    }

    command_shortcut_branch(){
        local SC_ITERATION_PATTERN
        SC_ITERATION_PATTERN="${1:-Ops}"

        echo "Search story pattern ${SC_ITERATION_PATTERN}"

        local SC_ITERATION
        SC_ITERATION=$(curl --silent -X GET -H "Content-Type: application/json" -H "Shortcut-Token: $SHORTCUT_API_TOKEN" -d '{ "detail": "slim", "page_size": 10, "query": "'${SC_ITERATION_PATTERN}'" }' -L "https://api.app.shortcut.com/api/v3/search/iterations" | jq --raw-output '.data[] | select(.status=="started") | (.id|tostring) + " - " + .name' | fzf --height=20 --ansi --reverse --select-1)

        if [ -z "${SC_ITERATION}" ]
        then
            echo "No iteration selected aborted"
            return
        fi

        local SC_ITERATION_ID
        SC_ITERATION_ID=$(echo ${SC_ITERATION} | awk '{print $1}')
        echo "${SC_ITERATION} => ${SC_ITERATION_ID}"

        local SC_STORY
        SC_STORY=$(curl --silent -H "Content-Type: application/json" -H "Shortcut-Token: $SHORTCUT_API_TOKEN" -L "https://api.app.shortcut.com/api/v3/iterations/${SC_ITERATION_ID}/stories" | jq --raw-output '.[] | (.id|tostring) + " - " + .story_type + " : " + .name' | fzf --height=20 --ansi --reverse --select-1)

        if [ -z "${SC_STORY}" ]
        then
            echo "No story selected aborted"
            return
        fi

        local SC_STORY_TYPE
        SC_STORY_TYPE=$(echo ${SC_STORY} | awk '{print $3}')
        local SC_STORY_ID
        SC_STORY_ID=$(echo ${SC_STORY} | awk '{print $1}')
        local SC_STORY_NAME
        SC_STORY_NAME=${SC_STORY##*:}
        # Trim spaces
        SC_STORY_NAME=${SC_STORY_NAME## }
        SC_STORY_NAME=${SC_STORY_NAME%% }
        # Slugify branchname
        # From https://gist.github.com/oneohthree/f528c7ae1e701ad990e6
        SC_STORY_NAME=$(echo "${SC_STORY_NAME}" | iconv -c -t ascii//TRANSLIT | sed -E 's/[~^]+//g' | sed -E 's/[^a-zA-Z0-9]+/-/g' | sed -E 's/^-+|-+$//g' | tr A-Z a-z)

        local SC_BRANCH_NAME
        SC_BRANCH_NAME="${SC_STORY_TYPE}/sc-${SC_STORY_ID}_${SC_STORY_NAME}"

        echo "Create branch for ${SC_BRANCH_NAME}"

        git checkout -b "${SC_BRANCH_NAME}"
    }

    command_shortcut(){
        subcommand=$1

        case "${subcommand}" in
        "branch")
            shift
            command_shortcut_branch
            ;;
        *)
            command_shortcut_help
            ;;
        esac
    }

    command_ovh_manager(){
        echo "Running 'ovh/manager' command."

        _b3t_cache

        TARGET=$(yq  '.instances[] | select(.status == "active")  | .name + " | " + .asset_tag' "${B3T_CACHE_FILE_DEVICES}" | uniq | fzf --height=20 --ansi --reverse --select-1)
        if [ -z "${TARGET}" ]
        then
            echo "No host selected aborted"
            return
        fi

        ASSET_TAG=$(echo "${TARGET}" | awk -F' | ' '{ print $3 }')

        echo "https://www.ovh.com/manager/#/dedicated/server/${ASSET_TAG}"
    }

    command_ovh_help(){
        echo "Usage: $BIN_NAME ovh <subcommand>\n"
        echo "Subcommands:"
        echo "    manager          open ovh manager on instance"
    }

    command_ovh(){
        subcommand=$1

        case "${subcommand}" in
        "manager")
            shift
            command_ovh_manager $@
            ;;
        *)
            command_ovh_help
            ;;
        esac
    }

    command_kubernetes_help(){
        echo "Usage: $BIN_NAME kubernetes|k8s <subcommand>\n"
        echo "Subcommands:"
        echo "    get              retrieve kubeconfig from 1password"
        echo "    switch           set KUBECONFIG env vars to specific files"
        echo "    default          copy merge kubeconfig to default .kube/config"
    }

    command_kubernetes(){
        subcommand=$1

        case "${subcommand}" in
        "get")
            shift
            command_kubernetes_config $@
            ;;
        "switch")
            shift
            command_kubernetes_switch $@
            ;;
        "default")
            shift
            command_kubernetes_default
            ;;
        *)
            command_kubernetes_help
            ;;
        esac
    }

    command_kubernetes_switch(){
        local KUBECONFIG_SELECT
        KUBECONFIG_SELECT=$(find "${B3T_KUBE_CONFIG_DIR}/b3t" | fzf)
        printf "${KUBECONFIG_SELECT}\n"
        export KUBECONFIG="${KUBECONFIG_SELECT}"
    }

    command_kubernetes_default(){
        cp "${B3T_KUBE_CONFIG_DIR}/b3t/all.yaml" "${HOME}/.kube/config"
    }

    command_kubernetes_config(){
        if [ -z "${B3T_KUBE_CLUSTERS}" ]
        then
            echo "ERROR: B3T_KUBE_CLUSTERS is not set"
            return
        fi

        if [ -z "${B3T_KUBERNETES_OP_VAULT}" ]
        then
            echo "ERROR: B3T_KUBERNETES_OP_VAULT is not set"
            return
        fi

        if ! [ -d "${B3T_KUBE_CONFIG_DIR}/b3t" ]
        then
            mkdir -p "${B3T_KUBE_CONFIG_DIR}/b3t"
        fi

        local KUBE_CLUSTERS
        KUBE_CLUSTERS=($B3T_KUBE_CLUSTERS)

        for FILE in "${KUBE_CLUSTERS[@]}"; do
            printf "Retrieve kubeconfig for ${FILE/.yaml/}\n"
            op read "op://${B3T_KUBERNETES_OP_VAULT}/kubeconfig/${FILE}?attribute=content" > "${B3T_KUBE_CONFIG_DIR}/b3t/${FILE}"
        done

        local PATH_KUBECONFIG_FILES
        PATH_KUBECONFIG_FILES=()
        for FILE in "${KUBE_CLUSTERS[@]}"; do
          PATH_KUBECONFIG_FILES+=("${B3T_KUBE_CONFIG_DIR}/b3t/${FILE}")
        done

        local KUBECONFIG_ALL
        KUBECONFIG_ALL=$(IFS=: ; echo "${PATH_KUBECONFIG_FILES[*]}")

        KUBECONFIG="${KUBECONFIG_ALL}" kubectl config view --flatten > "${B3T_KUBE_CONFIG_DIR}/b3t/all.yaml"
    }

    command_talos(){
        subcommand=$1

        case "${subcommand}" in
        "config")
            shift
            command_talos_config $@
            ;;
        "files")
            shift
            command_talos_files $@
            ;;
        *)
            command_talos_help
            ;;
        esac
    }

    command_talos_files(){
        subcommand=$1

        case "${subcommand}" in
        "get")
            shift
            command_talos_files_get $@
            ;;
        *)
            command_talos_files_help
            ;;
        esac
    }

    command_talos_switch(){
        TALOSCONFIG_SELECT=$(find "${B3T_TALOS_DIR}" -name talosconfig | fzf)

        export TALOSCONFIG="${TALOSCONFIG_SELECT}"
    }

    command_talos_config_get() {
        if [ -z "${B3T_TALOS_OP_VAULT}" ]
        then
            echo "ERROR: B3T_TALOS_OP_VAULT is not fill"
            return
        fi

        local CLUSTER_NAME
        CLUSTER_NAME="${1}"

        if [ -z "${CLUSTER_NAME}" ]
        then
            echo "ERROR: no cluster name give by argument"
            return
        fi

        printf "Retrieve talosconfig file for cluster ${CLUSTER_NAME} (save in ${B3T_TALOS_DIR}/${CLUSTER_NAME})\n"
        TALOS_FILES=(talosconfig)

        if ! [ -d "${B3T_TALOS_DIR}/${CLUSTER_NAME}" ]
        then
            mkdir -p "${B3T_TALOS_DIR}/${CLUSTER_NAME}"
        fi

        for FILE in "${TALOS_FILES[@]}"; do
            printf "Retrieve ${FILE}\n"
            op read "op://${B3T_TALOS_OP_VAULT}/Talos - ${CLUSTER_NAME}/${FILE}?attribute=content" > "${B3T_TALOS_DIR}/${CLUSTER_NAME}/${FILE}"
        done
    }

    command_talos_files_get() {
        if [ -z "${B3T_TALOS_OP_VAULT}" ]
        then
            echo "ERROR: B3T_TALOS_OP_VAULT is not fill"
            return
        fi

        local CLUSTER_NAME
        CLUSTER_NAME="${1}"
        if [ -z "${CLUSTER_NAME}" ]
        then
            echo "ERROR: no cluster name give by argument"
            return
        fi

        local LOCAL_PATH
        LOCAL_PATH="${2}"
        if [ -z "${LOCAL_PATH}" ]
        then
            LOCAL_PATH="${B3T_TALOS_DIR}/${CLUSTER_NAME}"
        fi

        printf "Retrieve talos generated files for cluster ${CLUSTER_NAME} (save in ${LOCAL_PATH})\n"
        TALOS_FILES=(secrets.yaml worker.yaml controlplane.yaml)

        if ! [ -d "${LOCAL_PATH}" ]
        then
            mkdir -p "${LOCAL_PATH}"
        fi

        for FILE in "${TALOS_FILES[@]}"; do
            printf "Retrieve ${FILE}\n"
            op read "op://${B3T_TALOS_OP_VAULT}/Talos - ${CLUSTER_NAME}/${FILE}?attribute=content" > "${LOCAL_PATH}/${FILE}"
        done
    }

    command_talos_config(){
        subcommand=$1

        case "${subcommand}" in
        "get")
            shift
            command_talos_config_get $@
            ;;
        "switch")
            shift
            command_talos_switch $@
            ;;
        *)
            command_talos_config_help
            ;;
        esac
    }

    command_talos_files_help(){
        echo "Usage: $BIN_NAME talos files <subcommand> <cluster>\n"
        echo "Subcommands:"
        echo "    get   retrieve configuration files for talos (controlplane, worker, secrets)"
    }

    command_talos_help(){
        echo "Usage: $BIN_NAME talos <subcommand>\n"
        echo "Subcommands:"
        echo "    config   interract with talosconfig files"
        echo "    files    interract with talos generated files"
    }

    command_talos_config_help(){
        echo "Usage: $BIN_NAME talos config <subcommand>\n"
        echo "Subcommands:"
        echo "    get      retrieve all talosconfig for given cluster"
        echo "    switch   change talos context"
    }

    command_netbox_search() {
        local NETBOX_SEARCH_PATTERN
        NETBOX_SEARCH_PATTERN="${1}"

        if [ -z "$NETBOX_SEARCH_PATTERN" ]
        then
            echo "Search is empty, result will be limited to netbox default pagination"
        fi

        local NETBOX_SEARCH_DEVICES
        NETBOX_SEARCH_DEVICES=$(curl --silent -H "Content-Type: application/json" -H "Authorization: Token $NETBOX_API_TOKEN" -L "https://${NETBOX_URL}/api/dcim/devices/?q=${NETBOX_SEARCH_PATTERN}" | jq --raw-output '.results[] | (.id|tostring) + " - baremetal - " + .name')

        local NETBOX_SEARCH_VM
        NETBOX_SEARCH_VM=$(curl --silent -H "Content-Type: application/json" -H "Authorization: Token $NETBOX_API_TOKEN" -L "https://${NETBOX_URL}/api/virtualization/virtual-machines/?q=${NETBOX_SEARCH_PATTERN}" | jq --raw-output '.results[] | (.id|tostring) + " - VM - " + .name')

        local NETBOX_SELECTED_ITEM
        NETBOX_SELECTED_ITEM=$(echo "${NETBOX_SEARCH_VM} ${NETBOX_SEARCH_DEVICES}" | fzf --height=20 --ansi --reverse --select-1)

        NETBOX_SELECTED_ITEM_TYPE=$(echo ${NETBOX_SELECTED_ITEM} | awk -F' - ' '{print $2}')
        NETBOX_SELECTED_ITEM_ID=$(echo ${NETBOX_SELECTED_ITEM} | awk -F' - ' '{print $1}')

        local NETBOX_SELECTED_ITEM_CONTENT
        if [ "${NETBOX_SELECTED_ITEM_TYPE}" == "VM" ]; then
            NETBOX_SELECTED_ITEM_CONTENT=$(curl --silent -H "Content-Type: application/json" -H "Authorization: Token $NETBOX_API_TOKEN" -L "https://${NETBOX_URL}/api/virtualization/virtual-machines/${NETBOX_SELECTED_ITEM_ID}" | jq .)
            NETBOX_SELECTED_ITEM_URL="https://${NETBOX_URL}/virtualization/virtual-machines/${NETBOX_SELECTED_ITEM_ID}"
        else
            NETBOX_SELECTED_ITEM_CONTENT=$(curl --silent -H "Content-Type: application/json" -H "Authorization: Token $NETBOX_API_TOKEN" -L "https://${NETBOX_URL}/api/dcim/devices/${NETBOX_SELECTED_ITEM_ID}" | jq .)
            NETBOX_SELECTED_ITEM_URL="https://${NETBOX_URL}/dcim/devices/${NETBOX_SELECTED_ITEM_ID}"
        fi

        echo -e "Information retrieve from netbox: \n${NETBOX_SELECTED_ITEM_CONTENT}"

        echo "Netbox: ${NETBOX_SELECTED_ITEM_URL}"
    }

    command_netbox_search_browser() {
        local OS=$(uname -s | tr '[:upper:]' '[:lower:]')

        if [ "${OS}" = "darwin" ]; then
            open "https://${NETBOX_URL}/search/?&obj_types=dcim.device&obj_types=virtualization.virtualmachine&q=$1"
        else
            xdg-open "https://${NETBOX_URL}/search/?&obj_types=dcim.device&obj_types=virtualization.virtualmachine&q=$1"
        fi
    }

    command_netbox_export() {
        local NETBOX_SEARCH_PATTERN
        NETBOX_SEARCH_PATTERN="${1}"

        if [ -z "$NETBOX_SEARCH_PATTERN" ]
        then
            echo "Search is empty, result will be limited to netbox default pagination"
        fi

        local NETBOX_SEARCH_DEVICES
        NETBOX_SEARCH_DEVICES=$(curl --silent -H "Content-Type: application/json" -H "Authorization: Token $NETBOX_API_TOKEN" -L "https://${NETBOX_URL}/api/dcim/devices/?q=${NETBOX_SEARCH_PATTERN}" | jq --raw-output '.results[] | (.id|tostring) + " - " + .name')

        echo -e "Devices retrieved: ${NETBOX_SEARCH_DEVICES}"

        read -p "Export (y/n)?" CONT
        if [ "$CONT" = "y" ]; then
            echo -e "Select export format"
            local NETBOX_EXPORT_SELECTED
            NETBOX_EXPORT_SELECTED=$(curl --silent -H "Content-Type: application/json" -H "Authorization: Token $NETBOX_API_TOKEN" -L "https://${NETBOX_URL}/api/extras/export-templates/" | jq --raw-output '.results[] | (.id|tostring) + " - " + .name' | fzf --height=20 --ansi --reverse)
            local NETBOX_EXPORT_SELECTED_NAME
            NETBOX_EXPORT_SELECTED_NAME=$(echo ${NETBOX_EXPORT_SELECTED} | awk -F' - ' '{print $2}')

            local NETBOX_EXPORT_FILENAME
            NETBOX_EXPORT_FILENAME="$(date +'%Y%m%d_%H%M')_${NETBOX_SEARCH_PATTERN}.txt"

            echo "Exporting to ${NETBOX_EXPORT_FILENAME}"

            curl --silent -H "Content-Type: application/json" -H "Authorization: Token $NETBOX_API_TOKEN" -L "https://${NETBOX_URL}/api/dcim/devices/?q=${NETBOX_SEARCH_PATTERN}&export=${NETBOX_EXPORT_SELECTED_NAME}" > "./${NETBOX_EXPORT_FILENAME}"
        else
            echo "Okay bye!"
        fi
    }

    command_netbox(){
        subcommand=$1

        case "${subcommand}" in
        "cache_reload")
            shift
            command_netbox_cache_reload
            ;;
        "search")
            shift
            command_netbox_search $@
            ;;
        "search_browser")
            shift
            command_netbox_search_browser $@
            ;;
        "export")
            shift
            command_netbox_export $@
            ;;
        *)
            command_talos_config_help
            ;;
        esac
    }

    command_netbox_cache_reload(){
        echo "Running 'netbox/cache_reload' command."
        rm "${B3T_CACHE_FILE_VM}" "${B3T_CACHE_FILE_DEVICES}" || true
        _b3t_cache
    }

    command_netbox_help(){
        echo "Usage: $BIN_NAME netbox <subcommand>\n"
        echo "Subcommands:"
        echo "    cache_reload           refresh local cached informations"
        echo "    search_browser         open in default brower UI to netbox in search mode (devices and vm)"
        echo "    search                 search devices or vms"
        echo "    export                 search devices or vms and export to disk"
    }

    command=$1
    case "${command}" in
        "ssh")
            shift
            command_ssh $@
        ;;
        "sc"|"shortcut")
            shift
            command_shortcut $@
        ;;
        "talos")
            shift
            command_talos $@
        ;;
        "k8s"|"kubernetes")
            shift
            command_kubernetes $@
        ;;
        "ovh")
            shift
            command_ovh $@
        ;;
        "netbox")
            shift
            command_netbox $@
        ;;
        *)
            command_help
        ;;
    esac
}

_b3t_autocomplete() {
    local cur=${COMP_WORDS[COMP_CWORD]}
    local prev1=${COMP_WORDS[COMP_CWORD-1]}
    local prev2=${COMP_WORDS[COMP_CWORD-2]}

    local root_options=("ssh" "shortcut" "sc" "k8s" "kubernetes" "talos" "ovh" "netbox")
    local ssh_options=("connect" "scan")
    local shortcut_options=("branch")
    local ovh_options=("manager")
    local netbox_options=("cache_reload" "search_browser" "search" "export")
    local talos_options=("config" "files")
    local talos_config_options=("get" "switch")
    local talos_files_options=("get")
    local kubernetes_options=("get" "switch" "default")

    case "$prev2 $prev1" in
        "talos files")
            COMPREPLY=($(compgen -W "${talos_files_options[*]}" -- "$cur"))
            ;;
        "talos config")
            COMPREPLY=($(compgen -W "${talos_config_options[*]}" -- "$cur"))
            ;;
        *)
            case "$prev1" in
                "ssh")
                    COMPREPLY=($(compgen -W "${ssh_options[*]}" -- "$cur"))
                    ;;
                "talos")
                    COMPREPLY=($(compgen -W "${talos_options[*]}" -- "$cur"))
                    ;;
                "k8s"|"kubernetes")
                    COMPREPLY=($(compgen -W "${kubernetes_options[*]}" -- "$cur"))
                    ;;
                "ovh")
                    COMPREPLY=($(compgen -W "${ovh_options[*]}" -- "$cur"))
                    ;;
                "shortcut"|"sc")
                    COMPREPLY=($(compgen -W "${shortcut_options[*]}" -- "$cur"))
                    ;;
                "netbox")
                    COMPREPLY=($(compgen -W "${netbox_options[*]}" -- "$cur"))
                    ;;
                *)
                    COMPREPLY=($(compgen -W "${root_options[*]}" -- "$cur"))
                    ;;
            esac
            ;;
    esac
}

complete -F _b3t_autocomplete b3t

alias bssh="b3t ssh connect"
