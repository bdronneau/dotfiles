#!/usr/bin/env bash

##############
# Requirements
##############
# environnement variables
# - B3T_SSH_PORT: if need custom port for ssh-keyscan
# - NETBOX_API_TOKEN: in order to interract with Netbox
# - NETBOX_URL: netbox url target (exemple foo.bar). Note https is mandatory
# external tools
# - fzf
# - yq
# - curl
# - ssh
# - ssh-keyscan
# - git
# SSH command are based on elements retrieved with netbox export
# ensure you have b3t export templates
# instances:
# {%- for device in queryset %}
#   - name: "{{device.name}}"
#     status: "{{device.status}}"
# {%- endfor %}

b3t(){
    local BIN_NAME
    BIN_NAME="b3t"
    local B3T_CONFIG_DIR
    B3T_CONFIG_DIR="${HOME}/.config/b3t"
    local B3T_CACHE_DIR
    B3T_CACHE_DIR="${B3T_CONFIG_DIR}/cache"
    local B3T_CACHE_FILE_VM
    B3T_CACHE_FILE_VM="${B3T_CACHE_DIR}/vms.yaml"
    local B3T_CACHE_FILE_DEVICES
    B3T_CACHE_FILE_DEVICES="${B3T_CACHE_DIR}/devices.yaml"
    local B3T_KNOWN_HOSTS_FILE
    B3T_KNOWN_HOSTS_FILE="${B3T_CONFIG_DIR}/known_hosts"
    local B3T_SSH_PORT
    B3T_SSH_PORT="${B3T_SSH_PORT:-22}"

    local B3T_TALOS_DIR
    B3T_TALOS_DIR="${HOME}/.talos"

    local B3T_KUBE_CONFIG_DIR
    B3T_KUBE_CONFIG_DIR="${HOME}/.kube"

    if [ ! -d "$B3T_CONFIG_DIR" ]; then
        echo "First run create b3t config dir => ${B3T_CONFIG_DIR}"
        mkdir -p ${B3T_CONFIG_DIR}
    fi

    command_help(){
        echo "Usage: $BIN_NAME <subcommand>"
        echo "Subcommands:"
        echo "    ssh              Helpers to dialog with infrastructure"
        echo "    shortcut|sc      Helpers to dialog with shortcut"
        echo "    k8s|kubernetes   Helpers to dialog with k8s"
        echo "    talos            Helpers to dialog with talos"
    }

    command_ssh_scan(){
        echo "Running 'ssh/scan' command."

        _ssh_cache

        cat /dev/null > "${B3T_KNOWN_HOSTS_FILE}"

        for entry in $(yq .instances "${B3T_CACHE_FILE_DEVICES}" "${B3T_CACHE_FILE_VM}" | yq '.[] | select(.status == "active") | .name'); do
            echo "Processing device: ${entry}:${B3T_SSH_PORT}"
            ssh-keyscan -p "${B3T_SSH_PORT}" "${entry}" >> "${B3T_KNOWN_HOSTS_FILE}"
        done
    }

    command_ssh_connect(){
        echo "Running 'ssh/connect' command."

        SSH_TARGET=$(awk -F'[][]' '{ if (NF > 2) print $2 }' "${B3T_KNOWN_HOSTS_FILE}" | uniq | fzf --height=20 --ansi --reverse --select-1)
        if [ -z "${SSH_TARGET}" ]
        then
            echo "No host selected aborted"
            return
        fi

        history -s ssh ${SSH_TARGET}
        ssh ${SSH_TARGET}
    }

    _ssh_cache(){
        if [ ! -d "$B3T_CACHE_DIR" ]; then
            echo "First run create b3t cache => ${B3T_CACHE_DIR}"
            mkdir -p ${B3T_CACHE_DIR}
        fi

        if [ ! -f "${B3T_CACHE_FILE_VM}" ] || [ ! -f "${B3T_CACHE_FILE_DEVICES}" ]; then
            echo "Populate cache"

            mkdir -p ${B3T_CACHE_DIR}
            curl -o "${B3T_CACHE_DIR}/devices.yaml" --silent -H "Content-Type: application/json" -H "Authorization: Token $NETBOX_API_TOKEN" -L "https://${NETBOX_URL}/api/dcim/devices/?export=b3t"
            curl -o "${B3T_CACHE_DIR}/vms.yaml" --silent -H "Content-Type: application/json" -H "Authorization: Token $NETBOX_API_TOKEN" -L "https://${NETBOX_URL}/api/virtualization/virtual-machines/?export=b3t"
        fi
    }

    command_ssh_cache_reload(){
        echo "Running 'ssh/cache_clear' command."
        rm "${B3T_CACHE_FILE_VM}" "${B3T_CACHE_FILE_DEVICES}" || true
        _ssh_cache
    }

    command_ssh_help(){
        echo "Usage: $BIN_NAME ssh <subcommand>\n"
        echo "Subcommands:"
        echo "    connect           make ssh connection to one instance"
        echo "    scan              (re)populate ssh_knows_hosts with fingerprint"
        echo "    cache_reload      clear cache files from netbox export"
    }

    command_ssh(){
        subcommand=$1

        case "${subcommand}" in
        "connect")
            shift
            command_ssh_connect
            ;;
        "scan")
            shift
            command_ssh_scan
            ;;
        "cache_reload")
            shift
            command_ssh_cache_reload
            ;;
        *)
            command_ssh_help
            ;;
        esac
    }

    command_shortcut_help(){
        echo "Usage: $BIN_NAME shortcut <subcommand>\n"
        echo "Subcommands:"
        echo "    branch   create branch base on ticket number"
    }

    command_shortcut_branch(){
        local SC_ITERATION_PATTERN
        SC_ITERATION_PATTERN="${1:-Ops}"

        echo "Search story pattern ${SC_ITERATION_PATTERN}"

        local SC_ITERATION
        SC_ITERATION=$(curl --silent -X GET -H "Content-Type: application/json" -H "Shortcut-Token: $SHORTCUT_API_TOKEN" -d '{ "detail": "slim", "page_size": 10, "query": "'${SC_ITERATION_PATTERN}'" }' -L "https://api.app.shortcut.com/api/v3/search/iterations" | jq --raw-output '.data[] | select(.status=="started") | (.id|tostring) + " - " + .name' | fzf --height=20 --ansi --reverse --select-1)

        if [ -z "${SC_ITERATION}" ]
        then
            echo "No iteration selected aborted"
            return
        fi

        local SC_ITERATION_ID
        SC_ITERATION_ID=$(echo ${SC_ITERATION} | awk '{print $1}')
        echo "${SC_ITERATION} => ${SC_ITERATION_ID}"

        local SC_STORY
        SC_STORY=$(curl --silent -H "Content-Type: application/json" -H "Shortcut-Token: $SHORTCUT_API_TOKEN" -L "https://api.app.shortcut.com/api/v3/iterations/${SC_ITERATION_ID}/stories" | jq --raw-output '.[] | (.id|tostring) + " - " + .story_type + " : " + .name' | fzf --height=20 --ansi --reverse --select-1)

        if [ -z "${SC_STORY}" ]
        then
            echo "No story selected aborted"
            return
        fi

        local SC_STORY_TYPE
        SC_STORY_TYPE=$(echo ${SC_STORY} | awk '{print $3}')
        local SC_STORY_ID
        SC_STORY_ID=$(echo ${SC_STORY} | awk '{print $1}')
        local SC_STORY_NAME
        SC_STORY_NAME=${SC_STORY##*:}
        # Trim spaces
        SC_STORY_NAME=${SC_STORY_NAME## }
        SC_STORY_NAME=${SC_STORY_NAME%% }
        # Slugify branchname
        # From https://gist.github.com/oneohthree/f528c7ae1e701ad990e6
        SC_STORY_NAME=$(echo "${SC_STORY_NAME}" | iconv -c -t ascii//TRANSLIT | sed -E 's/[~^]+//g' | sed -E 's/[^a-zA-Z0-9]+/-/g' | sed -E 's/^-+|-+$//g' | tr A-Z a-z)

        local SC_BRANCH_NAME
        SC_BRANCH_NAME="${SC_STORY_TYPE}/sc-${SC_STORY_ID}_${SC_STORY_NAME}"

        echo "Create branch for ${SC_BRANCH_NAME}"

        git checkout -b "${SC_BRANCH_NAME}"
    }

    command_shortcut(){
        subcommand=$1

        case "${subcommand}" in
        "branch")
            shift
            command_shortcut_branch
            ;;
        *)
            command_shortcut_help
            ;;
        esac
    }

    command_kubernetes_help(){
        echo "Usage: $BIN_NAME kubernetes|k8s <subcommand>\n"
        echo "Subcommands:"
        echo "    get              retrieve kubeconfig from 1password"
        echo "    switch           set KUBECONFIG env vars to specific files"
        echo "    default          copy merge kubeconfig to default .kube/config"
    }

    command_kubernetes(){
        subcommand=$1

        case "${subcommand}" in
        "get")
            shift
            command_kubernetes_config $@
            ;;
        "switch")
            shift
            command_kubernetes_switch $@
            ;;
        "default")
            shift
            command_kubernetes_default
            ;;
        *)
            command_kubernetes_help
            ;;
        esac
    }

    command_kubernetes_switch(){
        local KUBECONFIG_SELECT
        KUBECONFIG_SELECT=$(find "${B3T_KUBE_CONFIG_DIR}/b3t" | fzf)
        printf "${KUBECONFIG_SELECT}\n"
        export KUBECONFIG="${KUBECONFIG_SELECT}"
    }

    command_kubernetes_default(){
        cp "${B3T_KUBE_CONFIG_DIR}/b3t/all.yaml" "${HOME}/.kube/config"
    }

    command_kubernetes_config(){
        if [ -z "${B3T_KUBE_CLUSTERS}" ]
        then
            echo "ERROR: B3T_KUBE_CLUSTERS is not set"
            return
        fi

        if [ -z "${B3T_KUBERNETES_OP_VAULT}" ]
        then
            echo "ERROR: B3T_KUBERNETES_OP_VAULT is not set"
            return
        fi

        if ! [ -d "${B3T_KUBE_CONFIG_DIR}/b3t" ]
        then
            mkdir -p "${B3T_KUBE_CONFIG_DIR}/b3t"
        fi

        local KUBE_CLUSTERS
        KUBE_CLUSTERS=($B3T_KUBE_CLUSTERS)

        for FILE in "${KUBE_CLUSTERS[@]}"; do
            printf "Retrieve kubeconfig for ${FILE/.yaml/}\n"
            op read "op://${B3T_KUBERNETES_OP_VAULT}/kubeconfig/${FILE}?attribute=content" > "${B3T_KUBE_CONFIG_DIR}/b3t/${FILE}"
        done

        local PATH_KUBECONFIG_FILES
        PATH_KUBECONFIG_FILES=()
        for FILE in "${KUBE_CLUSTERS[@]}"; do
          PATH_KUBECONFIG_FILES+=("${B3T_KUBE_CONFIG_DIR}/b3t/${FILE}")
        done

        local KUBECONFIG_ALL
        KUBECONFIG_ALL=$(IFS=: ; echo "${PATH_KUBECONFIG_FILES[*]}")

        KUBECONFIG="${KUBECONFIG_ALL}" kubectl config view --flatten > "${B3T_KUBE_CONFIG_DIR}/b3t/all.yaml"
    }

    command_talos(){
        subcommand=$1

        case "${subcommand}" in
        "config")
            shift
            command_talos_config $@
            ;;
        "files")
            shift
            command_talos_files $@
            ;;
        *)
            command_talos_help
            ;;
        esac
    }

    command_talos_files(){
        subcommand=$1

        case "${subcommand}" in
        "get")
            shift
            command_talos_files_get $@
            ;;
        *)
            command_talos_files_help
            ;;
        esac
    }

    command_talos_switch(){
        TALOSCONFIG_SELECT=$(find "${B3T_TALOS_DIR}" -name talosconfig | fzf)

        export TALOSCONFIG="${TALOSCONFIG_SELECT}"
    }

    command_talos_config_get() {
        if [ -z "${B3T_TALOS_OP_VAULT}" ]
        then
            echo "ERROR: B3T_TALOS_OP_VAULT is not fill"
            return
        fi

        local CLUSTER_NAME
        CLUSTER_NAME="${1}"

        if [ -z "${CLUSTER_NAME}" ]
        then
            echo "ERROR: no cluster name give by argument"
            return
        fi

        printf "Retrieve talosconfig file for cluster ${CLUSTER_NAME} (save in ${B3T_TALOS_DIR}/${CLUSTER_NAME})\n"
        TALOS_FILES=(secrets.yaml worker.yaml controlplane.yaml talosconfig)

        if ! [ -d "${B3T_TALOS_DIR}/${CLUSTER_NAME}" ]
        then
            mkdir -p "${B3T_TALOS_DIR}/${CLUSTER_NAME}"
        fi

        for FILE in "${TALOS_FILES[@]}"; do
            printf "Retrieve ${FILE}\n"
            op read "op://${B3T_TALOS_OP_VAULT}/Talos - ${CLUSTER_NAME}/${FILE}?attribute=content" > "${B3T_TALOS_DIR}/${CLUSTER_NAME}/${FILE}"
        done
    }

    command_talos_config(){
        subcommand=$1

        case "${subcommand}" in
        "get")
            shift
            command_talos_config_get $@
            ;;
        "switch")
            shift
            command_talos_switch $@
            ;;
        *)
            command_talos_config_help
            ;;
        esac
    }

    command_talos_files_help(){
        echo "Usage: $BIN_NAME talos files <subcommand> <cluster>\n"
        echo "Subcommands:"
        echo "    get   retrieve configuration files for talos (controlplane, worker, secrets)"
    }

    command_talos_help(){
        echo "Usage: $BIN_NAME talos <subcommand>\n"
        echo "Subcommands:"
        echo "    config   interract with talosconfig files"
    }

    command_talos_config_help(){
        echo "Usage: $BIN_NAME talos config <subcommand>\n"
        echo "Subcommands:"
        echo "    get      retrieve all talos files for given cluster"
        echo "    switch   change talos context"
    }

    command=$1
    case "${command}" in
        "ssh")
            shift
            command_ssh $@
        ;;
        "sc"|"shortcut")
            shift
            command_shortcut $@
        ;;
        "talos")
            shift
            command_talos $@
        ;;
        "k8s"|"kubernetes")
            shift
            command_kubernetes $@
        ;;
        *)
            command_help
        ;;
    esac
}

_b3t_root_autocomplete() {
    local completions=("ssh" "shortcut" "sc")
    local current_word="${COMP_WORDS[COMP_CWORD]}"
    COMPREPLY=($(compgen -W "${completions[*]}" -- "$current_word"))
}

_b3t_ssh_autocomplete() {
    local completions=("cache_reload" "connect" "scan")
    local current_word="${COMP_WORDS[COMP_CWORD]}"

    COMPREPLY=($(compgen -W "${completions[*]}" -- "$current_word"))
}

_b3t_shortcut_autocomplete() {
    local completions=("branch")
    local current_word="${COMP_WORDS[COMP_CWORD]}"

    COMPREPLY=($(compgen -W "${completions[*]}" -- "$current_word"))
}

_b3t_autocomplete() {
    local current_word="${COMP_WORDS[COMP_CWORD]}"

    case "${COMP_WORDS[1]}" in
        "ssh")
            _b3t_ssh_autocomplete
            ;;
        "shortcut"|"sc")
            _b3t_shortcut_autocomplete
            ;;
        *)
            _b3t_root_autocomplete
            ;;
    esac
}

complete -F _b3t_autocomplete b3t

alias bssh="b3t ssh connect"
